#include <iostream>

using namespace std;
//포인터와 메모리 해제(1)
int main() {
	//변수 선언 과정
	
	//int val = 3;
	//cout << &val << endl; //val이 라는 변수를 어디에 저장했는지 주소를 보는 방법
	
	//c++ : 객체지향 프로그래밍
	/*
	컴파일 시간이 아닌 실행 시간에 어떠한 결정을 내릴 수 있다. 
	- 배열 생성
	재래적/절차적 프로그래밍 : 배열의 크기가 컴파일 시간에 미리 결정
	객체지향 프로그래밍 : 배열의 크기를 실행 시간에 결정 가능
	*/
	
	
	//포인터 : 사용할 주소에 이름을 붙인다.
	//즉, 포인터는 포인터의 이름이 주소를 나타냄.	
	//간접값 연산자, 간접 참조 연산자 *
	
	//int *a; //c style
	//int* b; //c++ style
	//int* c, d; //c는 포인터 변수로 설정, d는 일반 int형 변수로 설정
	
	int a = 6; // << 정수
	int* b; // << 위치
	
	b = &a; // 포인터에는 어떠한 정수르 대입/연산이 의미가 없음
	//포인터는 이론적으론 정수와는 다른 데이터
	//a의 주소가 가르키고 있는 값이 6이기에, a와 같은 주소를 가지고 있는 b의 값 역시 6이 됩니다.


	
	cout << "a의 값 " << a << endl;
	cout << "*b의 값 " << *b << endl; //포인터로 선언된 변수는 *b처럼 *을 붙혀야 값을 확인 가능
	
	cout << "a의 주소 " << &a << endl;
	cout << "*b의 주소 " << b << endl; //포인터로 선언된 변수의 주소확인은 아무런 선언없이 b만 입력
	
	*b = *b + 1;//위처럼 포인터에 주소를 대입해준뒤 연산하는게 의미가 있음
	
	cout << "이제 a의 값은 " << a << endl;
	//b는 포인터로 선언되었기에, 그 자체로 주소를 가르킵니다. 
	//*b를 통해 그 주소가 가르키고 있는 값을 나타낼 수 있는데, 그 값이 증가시켰기 때문에, (a와 b는 주소가 같기 때문에) a의 값 역시 증가하게 된 것입니다.
	
	
	return 0;
}